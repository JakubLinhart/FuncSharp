<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../Helpers.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.ExceptionServices;

namespace FuncSharp
{
    
    public static class Try
    {
        /// <summary>
        /// Tries the specified action and returns its result if it succeeds. Otherwise in case of the specified exception,
        /// returns result of the recovery function.
        /// </summary>
        public static A Catch<A, E>(Func<Unit, A> action, Func<E, A> recover)
            where E : Exception
        {
            try
            {
                return action(Unit.Value);
            }
            catch (E e)
            {
                return recover(e);
            }
        }

        /// <summary>
        /// Create a new try with the result of the specified function while converting exceptions of the specified type
        /// into erroneous result.
        /// </summary>
        public static Try<A> Create<A, E>(Func<Unit, A> f)
            where E : Exception
        {
            return Catch<Try<A>, E>(
                _ => Success(f(Unit.Value)),
                e => Error<A>(e)
            );
        }

        /// <summary>
        /// Create a new try with the result of the specified function while converting all exceptions into erroneous result.
        /// </summary>
        public static Try<A> Create<A>(Func<Unit, A> f)
        {
            return Create<A, Exception>(f);
        }

        /// <summary>
        /// Creates a new try with a successful result.
        /// </summary>
        public static Try<A, E> Success<A, E>(A success)
        {
            return new Try<A, E>(success);
        }

        /// <summary>
        /// Creates a new try with a successful result.
        /// </summary>
        public static Try<A> Success<A>(A success)
        {
            return new Try<A>(success);
        }

        /// <summary>
        /// Creates a new try with an error result.
        /// </summary>
        public static Try<A, E> Error<A, E>(E error)
        {
            return new Try<A, E>(error);
        }

        /// <summary>
        /// Creates a new try with an exception result.
        /// </summary>
        public static Try<A> Error<A>(Exception exception)
        {
            return new Try<A>(new[] { exception });
        }

        /// <summary>
        /// Creates a new try with an exception result.
        /// </summary>
        public static Try<A> Error<A>(IEnumerable<Exception> exception)
        {
            return new Try<A>(exception);
        }

        /// <summary>
        /// Aggregates a collection of tries into a try of collection.
        /// </summary>
        public static Try<IEnumerable<A>> Aggregate<A>(IEnumerable<Try<A>> tries)
        {
            return Aggregate(
                tries,
                t => Success(t),
                e => Error<IEnumerable<A>>(e.SelectMany(error => error).ToList())
            );
        }

        /// <summary>
        /// Aggregates a collection of tries into a try of collection.
        /// </summary>
        public static Try<IEnumerable<A>, IEnumerable<E>> Aggregate<A, E>(IEnumerable<Try<A, E>> tries)
        {
            return Aggregate(
                tries,
                t => Success<IEnumerable<A>, IEnumerable<E>>(t),
                e => Error<IEnumerable<A>, IEnumerable<E>>(e)
            );
        }

        /// <summary>
        /// Aggregates a collection of tries into a try of collection.
        /// </summary>
        public static Try<IEnumerable<A>, IEnumerable<E>> Aggregate<A, E>(IEnumerable<Try<A, IEnumerable<E>>> tries)
        {
            return Aggregate(
                tries,
                t => Success<IEnumerable<A>, IEnumerable<E>>(t),
                e => Error<IEnumerable<A>, IEnumerable<E>>(e.SelectMany(error => error).ToList())
            );
        }

        /// <summary>
        /// Aggregates the tries using the specified function if all of them are successful. Otherwise aggregates the errors by given aggregate and calls error function.
        /// </summary>
        public static R Aggregate<T, R, E>(IEnumerable<Try<T, E>> tries, Func<IEnumerable<T>, R> success, Func<IEnumerable<E>, R> error)
        {
            var enumeratedTries = tries.ToList();
            if (enumeratedTries.All(t => t.IsSuccess))
            {
                return success(enumeratedTries.Select(t => t.Success).Flatten().ToList());
            }

            return error(enumeratedTries.Select(t => t.Error).Flatten());
        }
<#  for (var i = 2; i < MaxFuncArity(); i++) { #>

        /// <summary>
        /// Aggregates the tries using the specified function if all of them are successful. Otherwise aggregates the errors by given aggregate and calls error function.
        /// </summary>
        public static T Aggregate<<#= Types(i) #>, T, E>(<#= List(i, x => $"Try<{Type(x)}, E> t{x}") #>, Func<E, E, E> errorAggregate, Func<<#= Types(i) #>, T> success, Func<E, T> error)
        {
            if (<#= List(i, x => $"t{x}.IsSuccess", separator: " && ") #>)
            {
                return success(<#= List(i, x => $"t{x}.Success.Get()") #>);
            }

            var errors = new[] { <#= List(i, x => $"t{x}.Error") #> };
            return error(errors.Flatten().Aggregate(errorAggregate));
        }

        /// <summary>
        /// Aggregates the tries using the specified function if all of them are successful. Otherwise aggregates all errors into error result by concatenation.
        /// </summary>
        public static Try<R, IEnumerable<E>> Aggregate<<#= Types(i) #>, R, E>(<#= List(i, x => $"Try<T{x}, IEnumerable<E>> t{x}") #>, Func<<#= Types(i) #>, R> f)
        {
            return Aggregate(<#= List(i, x => $"t{x}") #>, (e1, e2) => e1.Concat(e2), (<#= List(i, x => $"s{x}") #>) => Success<R, IEnumerable<E>>(f(<#= List(i, x => $"s{x}") #>)), Error<R, IEnumerable<E>>);
        }

        /// <summary>
        /// Aggregates the tries using the specified function if all of them are successful. Otherwise aggregates all exceptions into error result by concatenation.
        /// </summary>
        public static Try<R> Aggregate<<#= Types(i) #>, R>(<#= List(i, x => $"Try<T{x}> t{x}") #>, Func<<#= Types(i) #>, R> f)
        {
            return Aggregate(<#= List(i, x => $"t{x}") #>, (e1, e2) => e1.Concat(e2), (<#= List(i, x => $"s{x}") #>) => Success<R>(f(<#= List(i, x => $"s{x}") #>)), Error<R>);
        }
<#  } #>
    }

    /// <summary>
    /// Result of an operation that may either succeed or fail with an error.
    /// </summary>
    public class Try<A, E> : Coproduct2<A, E>
    {
        internal Try(A success)
            : base(success)
        {
        }

        internal Try(E error)
            : base(error)
        {
        }

        /// <summary>
        /// Returns whether the result is a success.
        /// </summary>
        public bool IsSuccess
        {
            get { return IsFirst; }
        }

        /// <summary>
        /// Returns whether the result is an error.
        /// </summary>
        public bool IsError
        {
            get { return IsSecond; }
        }

        /// <summary>
        /// Returns the successful result.
        /// </summary>
        public Option<A> Success
        {
            get { return First; }
        }

        /// <summary>
        /// Returns the error result.
        /// </summary>
        public Option<E> Error
        {
            get { return Second; }
        }

        /// <summary>
        /// Maps the successful result to a new successful result.
        /// </summary>
        public Try<B, E> Map<B>(Func<A, B> f)
        {
            return Match(
                s => Try.Success<B, E>(f(s)),
                e => Try.Error<B, E>(e)
            );
        }

        /// <summary>
        /// Maps the error result to a new error result.
        /// </summary>
        public Try<A, F> MapError<F>(Func<E, F> f)
        {
            return Match(
                s => Try.Success<A, F>(s),
                e => Try.Error<A, F>(f(e))
            );
        }
    }

    /// <summary>
    /// Result of an operation that may either succeed or fail with exception.
    /// </summary>
    public class Try<A> : Try<A, IEnumerable<Exception>>
    {
        internal Try(A success)
            : base(success)
        {
        }

        internal Try(IEnumerable<Exception> exceptions)
            : base(exceptions)
        {
        }

        /// <summary>
        /// If the result is success, returns it. Otherwise throws the exception result.
        /// </summary>
        public A Get()
        {
            return Match(
                s => s,
                e =>
                {
                    var exception = e.SingleOption();
                    if (exception.NonEmpty)
                    {
                        ExceptionDispatchInfo.Capture(exception.Get()).Throw();
                    }

                    throw new AggregateException(e);
                }
            );
        }

        /// <summary>
        /// Maps the successful result to a new successful result and erroneous result into new erroneous result.
        /// </summary>
        public Try<B> Map<B>(Func<A, B> f, Func<IEnumerable<Exception>, IEnumerable<Exception>> g)
        {
            return Match(
                s => Try.Success<B>(f(s)),
                e => Try.Error<B>(g(e))
            );
        }

        /// <summary>
        /// Maps the successful result to a new successful result and erroneous result into new erroneous result.
        /// </summary>
        public Try<B> Map<B>(Func<A, B> f, Func<IEnumerable<Exception>, Exception> g)
        {
            return Map(f, e => new[] { g(e) });
        }

        /// <summary>
        /// Maps the successful result to a new successful result.
        /// </summary>
        public new Try<B> Map<B>(Func<A, B> f)
        {
            return Map(f, e => e);
        }

        /// <summary>
        /// Maps the exception result to a new exception result.
        /// </summary>
        public Try<A> MapError(Func<IEnumerable<Exception>, IEnumerable<Exception>> f)
        {
            return Map(s => s, f);
        }

        /// <summary>
        /// Maps the exception result to a new exception result.
        /// </summary>
        public Try<A> MapError(Func<IEnumerable<Exception>, Exception> f)
        {
            return MapError(e => new[] { f(e) });
        }

        /// <summary>
        /// Maps all the exceptions to new exceptions.
        /// </summary>
		public Try<A> MapError(Func<Exception, Exception> f)
        {
            return MapError(exceptions => exceptions.Select(f).ToList());
        }
    }
}
